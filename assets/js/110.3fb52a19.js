(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{707:function(e,n,t){"use strict";t.r(n);var a=t(39),r=Object(a.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("body",[n("script",{attrs:{src:"./Dvue.js"}}),this._v(" "),n("script",[this._v('\n    const app = new DVue({\n      data: {\n        test: "I am test",\n        foo: {\n          bar: "bar"\n        }\n      }\n    })\n\x3c!--beforebegin--\x3e<div class="language- extra-class">\x3c!--afterbegin--\x3e<pre><code>app.$data.test = &quot;hello world!&quot;\n// app.$data.foo.bar = &quot;hello!&quot;\nclass DVue {\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>constructor(options) {\nthis.$options = options</p>\n\x3c!--beforebegin--\x3e<div class="language- extra-class">\x3c!--afterbegin--\x3e<pre><code>// 数据响应化\nthis.$data = options.data\nthis.observe(this.$data)\n\n// 模拟一下watcher创建\n// 激活get 并将依赖添加到deps数组上\nnew Watcher()\nthis.$data.test\nnew Watcher()\nthis.$data.foo.bar\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>}</p>\n<p>observe(value) {\n// 判断value是否是对象\nif (!value || typeof value !== \'object\') {\nreturn\n}</p>\n\x3c!--beforebegin--\x3e<div class="language- extra-class">\x3c!--afterbegin--\x3e<pre><code>// 遍历该对象\nObject.keys(value).forEach(key =&gt; {\n  this.defineReactive(value, key, value[key])\n})\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>}</p>\n<p>// 数据响应化\ndefineReactive(obj, key, val) {\n// 判断val内是否还可以继续调用(是否还有对象)\nthis.observe(val) // 递归解决数据嵌套</p>\n\x3c!--beforebegin--\x3e<div class="language- extra-class">\x3c!--afterbegin--\x3e<pre><code>// 初始化dep\nconst dep = new Dep()\n\nObject.defineProperty(obj, key, {\n  get() {\n    // 读取的时候 判断Dep.target是否有，如果有则调用addDep方法将Dep.target添加到deps数组上\n    Dep.target &amp;&amp; dep.addDep(Dep.target)\n    return val\n  },\n  set(newVal) {\n    if (newVal === val) {\n      return;\n    }\n    val = newVal\n    // console.log(`${key}属性更新了：${val}`)\n    dep.notify()　// 更新时候调用该方法\n  }\n})\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>}\n}</p>\n<p>// Dep: 用来管理Watcher\nclass Dep {\nconstructor() {\n// 这里存放若干依赖(watcher) |一个watcher对应一个属性\nthis.deps = [];\n}</p>\n<p>// 添加依赖\naddDep (dep) {\nthis.deps.push(dep)\n}</p>\n<p>// 通知方法\nnotify() {\nthis.deps.forEach(dep =&gt; dep.update())\n}\n}</p>\n<p>// Watcher\nclass Watcher {\nconstructor () {\n// 将当前watcher实例指定到Dep静态属性target上\nDep.target = this   // 当前this就是Watcher对象\n}</p>\n<p>update() {\nconsole.log(\'属性更新了\')\n}\n}\n')])]),n("p")])}),[],!1,null,null,null);n.default=r.exports}}]);